<!-- # 进入 frontend 目录
# 在命令行里切换到你的 frontend/ 文件夹：

# cd E:/vscode_project/py_stu_code/my_voice_assistant/frontend
# 启动 Python 自带的简易 HTTP 服务器

# 如果你用的是 Python 3.x：

# python -m http.server 8000 -->

<!-- 访问 -->
<!-- http://localhost:8000/index.html -->


<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Live2D Desktop Pet</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: transparent;
      width: 100%;
      height: 100%;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;  /* ⭐️ 允许点击穿透到下方窗口 */
      z-index: 9999;
    }
  </style>
</head>
<body>
  <!-- PixiJS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/6.5.8/browser/pixi.min.js"></script>
  <!-- Cubism4 核心库 -->
  <script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script>
  <!-- pixi-live2d-display 的 Cubism4 构建 -->
  <script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/cubism4.min.js"></script>

  <canvas id="canvas"></canvas>

  <script>
    const { Live2DModel } = PIXI.live2d;

    const app = new PIXI.Application({
      view: document.getElementById('canvas'),
      width: window.innerWidth,
      height: window.innerHeight,
      transparent: true
    });

    window.addEventListener('resize', () => {
      app.renderer.resize(window.innerWidth, window.innerHeight);
    });

    Live2DModel.from('model/whitecatfree_vts/sdwhite cat free.model3.json')
      .then(model => {
        model.anchor.set(0.5, 1.0);
        model.scale.set(0.25);
        model.x = window.innerWidth / 2;
        model.y = window.innerHeight;
        app.stage.addChild(model);

        // 拖动逻辑（全局监听 + 命中测试）
        let dragging = false;
        let dragOffset = { x: 0, y: 0 };

        function getModelBounds() {
          const w = model.width * model.scale.x;
          const h = model.height * model.scale.y;
          const left = model.x - w * model.anchor.x;
          const right = left + w;
          const top = model.y - h * model.anchor.y;
          const bottom = top + h;
          return { left, right, top, bottom };
        }

        window.addEventListener('pointerdown', e => {
          const { left, right, top, bottom } = getModelBounds();
          if (e.clientX >= left && e.clientX <= right &&
              e.clientY >= top && e.clientY <= bottom) {
            dragging = true;
            dragOffset.x = e.clientX - model.x;
            dragOffset.y = e.clientY - model.y;
            e.preventDefault();  // ⭐️ 阻止点击继续冒泡（避免误触桌面）
          }
        });

        window.addEventListener('pointermove', e => {
          if (dragging) {
            model.x = e.clientX - dragOffset.x;
            model.y = e.clientY - dragOffset.y;
            e.preventDefault();
          }
        });

        window.addEventListener('pointerup', () => {
          dragging = false;
        });

        console.log('模型加载完成');
      })
      .catch(err => console.error('模型加载失败:', err));
  </script>
</body>
</html>



